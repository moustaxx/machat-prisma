### This file was generated by Nexus Schema
### Do not make changes to this file directly


input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type Conversation {
  createdAt: DateTime!
  id: Int!
  messages(after: MessageWhereUniqueInput, before: MessageWhereUniqueInput, first: Int, last: Int): [Message!]!
  name: String!
  participants(after: PersonWhereUniqueInput, before: PersonWhereUniqueInput, first: Int, last: Int): [Person!]!
}

type ConversationConnection {
  """
  https://facebook.github.io/relay/graphql/connections.htm#sec-Edge-Types
  """
  edges: [ConversationEdge!]!

  """
  https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!
}

input ConversationCreateInput {
  createdAt: DateTime
  lastRead: LastReadCreateManyWithoutConversationInput
  messages: MessageCreateManyWithoutConversationInput
  name: String!
  participants: PersonCreateManyWithoutConversationsInput
}

input ConversationCreateManyWithoutParticipantsInput {
  connect: [ConversationWhereUniqueInput!]
  connectOrCreate: [ConversationCreateOrConnectWithoutparticipantsInput!]
  create: [ConversationCreateWithoutParticipantsInput!]
}

input ConversationCreateOneWithoutLastReadInput {
  connect: ConversationWhereUniqueInput
  connectOrCreate: ConversationCreateOrConnectWithoutlastReadInput
  create: ConversationCreateWithoutLastReadInput
}

input ConversationCreateOneWithoutMessagesInput {
  connect: ConversationWhereUniqueInput
  connectOrCreate: ConversationCreateOrConnectWithoutmessagesInput
  create: ConversationCreateWithoutMessagesInput
}

input ConversationCreateOrConnectWithoutlastReadInput {
  create: ConversationCreateWithoutLastReadInput!
  where: ConversationWhereUniqueInput!
}

input ConversationCreateOrConnectWithoutmessagesInput {
  create: ConversationCreateWithoutMessagesInput!
  where: ConversationWhereUniqueInput!
}

input ConversationCreateOrConnectWithoutparticipantsInput {
  create: ConversationCreateWithoutParticipantsInput!
  where: ConversationWhereUniqueInput!
}

input ConversationCreateWithoutLastReadInput {
  createdAt: DateTime
  messages: MessageCreateManyWithoutConversationInput
  name: String!
  participants: PersonCreateManyWithoutConversationsInput
}

input ConversationCreateWithoutMessagesInput {
  createdAt: DateTime
  lastRead: LastReadCreateManyWithoutConversationInput
  name: String!
  participants: PersonCreateManyWithoutConversationsInput
}

input ConversationCreateWithoutParticipantsInput {
  createdAt: DateTime
  lastRead: LastReadCreateManyWithoutConversationInput
  messages: MessageCreateManyWithoutConversationInput
  name: String!
}

type ConversationEdge {
  """https://facebook.github.io/relay/graphql/connections.htm#sec-Cursor"""
  cursor: String!

  """https://facebook.github.io/relay/graphql/connections.htm#sec-Node"""
  node: Conversation!
}

input ConversationScalarWhereInput {
  AND: [ConversationScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  NOT: [ConversationScalarWhereInput!]
  OR: [ConversationScalarWhereInput!]
}

input ConversationUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  lastRead: LastReadUpdateManyWithoutConversationInput
  messages: MessageUpdateManyWithoutConversationInput
  name: StringFieldUpdateOperationsInput
  participants: PersonUpdateManyWithoutConversationsInput
}

input ConversationUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input ConversationUpdateManyWithoutParticipantsInput {
  connect: [ConversationWhereUniqueInput!]
  connectOrCreate: [ConversationCreateOrConnectWithoutparticipantsInput!]
  create: [ConversationCreateWithoutParticipantsInput!]
  delete: [ConversationWhereUniqueInput!]
  deleteMany: [ConversationScalarWhereInput!]
  disconnect: [ConversationWhereUniqueInput!]
  set: [ConversationWhereUniqueInput!]
  update: [ConversationUpdateWithWhereUniqueWithoutParticipantsInput!]
  updateMany: [ConversationUpdateManyWithWhereWithoutParticipantsInput!]
  upsert: [ConversationUpsertWithWhereUniqueWithoutParticipantsInput!]
}

input ConversationUpdateManyWithWhereWithoutParticipantsInput {
  data: ConversationUpdateManyMutationInput!
  where: ConversationScalarWhereInput!
}

input ConversationUpdateOneRequiredWithoutLastReadInput {
  connect: ConversationWhereUniqueInput
  connectOrCreate: ConversationCreateOrConnectWithoutlastReadInput
  create: ConversationCreateWithoutLastReadInput
  update: ConversationUpdateWithoutLastReadInput
  upsert: ConversationUpsertWithoutLastReadInput
}

input ConversationUpdateOneRequiredWithoutMessagesInput {
  connect: ConversationWhereUniqueInput
  connectOrCreate: ConversationCreateOrConnectWithoutmessagesInput
  create: ConversationCreateWithoutMessagesInput
  update: ConversationUpdateWithoutMessagesInput
  upsert: ConversationUpsertWithoutMessagesInput
}

input ConversationUpdateWithoutLastReadInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  messages: MessageUpdateManyWithoutConversationInput
  name: StringFieldUpdateOperationsInput
  participants: PersonUpdateManyWithoutConversationsInput
}

input ConversationUpdateWithoutMessagesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  lastRead: LastReadUpdateManyWithoutConversationInput
  name: StringFieldUpdateOperationsInput
  participants: PersonUpdateManyWithoutConversationsInput
}

input ConversationUpdateWithoutParticipantsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  lastRead: LastReadUpdateManyWithoutConversationInput
  messages: MessageUpdateManyWithoutConversationInput
  name: StringFieldUpdateOperationsInput
}

input ConversationUpdateWithWhereUniqueWithoutParticipantsInput {
  data: ConversationUpdateWithoutParticipantsInput!
  where: ConversationWhereUniqueInput!
}

input ConversationUpsertWithoutLastReadInput {
  create: ConversationCreateWithoutLastReadInput!
  update: ConversationUpdateWithoutLastReadInput!
}

input ConversationUpsertWithoutMessagesInput {
  create: ConversationCreateWithoutMessagesInput!
  update: ConversationUpdateWithoutMessagesInput!
}

input ConversationUpsertWithWhereUniqueWithoutParticipantsInput {
  create: ConversationCreateWithoutParticipantsInput!
  update: ConversationUpdateWithoutParticipantsInput!
  where: ConversationWhereUniqueInput!
}

input ConversationWhereUniqueInput {
  id: Int
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

type LastRead {
  conversation: Conversation!
  conversationID: Int!
  lastRead: DateTime!
  person: Person!
  personID: Int!
}

input LastReadCreateManyWithoutConversationInput {
  connect: [LastReadWhereUniqueInput!]
  connectOrCreate: [LastReadCreateOrConnectWithoutconversationInput!]
  create: [LastReadCreateWithoutConversationInput!]
}

input LastReadCreateManyWithoutPersonInput {
  connect: [LastReadWhereUniqueInput!]
  connectOrCreate: [LastReadCreateOrConnectWithoutpersonInput!]
  create: [LastReadCreateWithoutPersonInput!]
}

input LastReadCreateOrConnectWithoutconversationInput {
  create: LastReadCreateWithoutConversationInput!
  where: LastReadWhereUniqueInput!
}

input LastReadCreateOrConnectWithoutpersonInput {
  create: LastReadCreateWithoutPersonInput!
  where: LastReadWhereUniqueInput!
}

input LastReadCreateWithoutConversationInput {
  lastRead: DateTime!
  person: PersonCreateOneWithoutLastReadInput!
}

input LastReadCreateWithoutPersonInput {
  conversation: ConversationCreateOneWithoutLastReadInput!
  lastRead: DateTime!
}

input LastReadScalarWhereInput {
  AND: [LastReadScalarWhereInput!]
  conversationID: IntFilter
  lastRead: DateTimeFilter
  NOT: [LastReadScalarWhereInput!]
  OR: [LastReadScalarWhereInput!]
  personID: IntFilter
}

input LastReadUpdateManyMutationInput {
  lastRead: DateTimeFieldUpdateOperationsInput
}

input LastReadUpdateManyWithoutConversationInput {
  connect: [LastReadWhereUniqueInput!]
  connectOrCreate: [LastReadCreateOrConnectWithoutconversationInput!]
  create: [LastReadCreateWithoutConversationInput!]
  delete: [LastReadWhereUniqueInput!]
  deleteMany: [LastReadScalarWhereInput!]
  disconnect: [LastReadWhereUniqueInput!]
  set: [LastReadWhereUniqueInput!]
  update: [LastReadUpdateWithWhereUniqueWithoutConversationInput!]
  updateMany: [LastReadUpdateManyWithWhereWithoutConversationInput!]
  upsert: [LastReadUpsertWithWhereUniqueWithoutConversationInput!]
}

input LastReadUpdateManyWithoutPersonInput {
  connect: [LastReadWhereUniqueInput!]
  connectOrCreate: [LastReadCreateOrConnectWithoutpersonInput!]
  create: [LastReadCreateWithoutPersonInput!]
  delete: [LastReadWhereUniqueInput!]
  deleteMany: [LastReadScalarWhereInput!]
  disconnect: [LastReadWhereUniqueInput!]
  set: [LastReadWhereUniqueInput!]
  update: [LastReadUpdateWithWhereUniqueWithoutPersonInput!]
  updateMany: [LastReadUpdateManyWithWhereWithoutPersonInput!]
  upsert: [LastReadUpsertWithWhereUniqueWithoutPersonInput!]
}

input LastReadUpdateManyWithWhereWithoutConversationInput {
  data: LastReadUpdateManyMutationInput!
  where: LastReadScalarWhereInput!
}

input LastReadUpdateManyWithWhereWithoutPersonInput {
  data: LastReadUpdateManyMutationInput!
  where: LastReadScalarWhereInput!
}

input LastReadUpdateWithoutConversationInput {
  lastRead: DateTimeFieldUpdateOperationsInput
  person: PersonUpdateOneRequiredWithoutLastReadInput
}

input LastReadUpdateWithoutPersonInput {
  conversation: ConversationUpdateOneRequiredWithoutLastReadInput
  lastRead: DateTimeFieldUpdateOperationsInput
}

input LastReadUpdateWithWhereUniqueWithoutConversationInput {
  data: LastReadUpdateWithoutConversationInput!
  where: LastReadWhereUniqueInput!
}

input LastReadUpdateWithWhereUniqueWithoutPersonInput {
  data: LastReadUpdateWithoutPersonInput!
  where: LastReadWhereUniqueInput!
}

input LastReadUpsertWithWhereUniqueWithoutConversationInput {
  create: LastReadCreateWithoutConversationInput!
  update: LastReadUpdateWithoutConversationInput!
  where: LastReadWhereUniqueInput!
}

input LastReadUpsertWithWhereUniqueWithoutPersonInput {
  create: LastReadCreateWithoutPersonInput!
  update: LastReadUpdateWithoutPersonInput!
  where: LastReadWhereUniqueInput!
}

input LastReadWhereUniqueInput {
  personID_conversationID: PersonIDConversationIDCompoundUniqueInput
}

type Message {
  author: Person
  authorID: Int
  content: String!
  conversation: Conversation!
  conversationID: Int!
  createdAt: DateTime!
  id: Int!
}

input MessageCreateManyWithoutAuthorInput {
  connect: [MessageWhereUniqueInput!]
  connectOrCreate: [MessageCreateOrConnectWithoutauthorInput!]
  create: [MessageCreateWithoutAuthorInput!]
}

input MessageCreateManyWithoutConversationInput {
  connect: [MessageWhereUniqueInput!]
  connectOrCreate: [MessageCreateOrConnectWithoutconversationInput!]
  create: [MessageCreateWithoutConversationInput!]
}

input MessageCreateOrConnectWithoutauthorInput {
  create: MessageCreateWithoutAuthorInput!
  where: MessageWhereUniqueInput!
}

input MessageCreateOrConnectWithoutconversationInput {
  create: MessageCreateWithoutConversationInput!
  where: MessageWhereUniqueInput!
}

input MessageCreateWithoutAuthorInput {
  content: String!
  conversation: ConversationCreateOneWithoutMessagesInput!
  createdAt: DateTime
}

input MessageCreateWithoutConversationInput {
  author: PersonCreateOneWithoutMessagesInput
  content: String!
  createdAt: DateTime
}

input MessageScalarWhereInput {
  AND: [MessageScalarWhereInput!]
  authorID: IntNullableFilter
  content: StringFilter
  conversationID: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  NOT: [MessageScalarWhereInput!]
  OR: [MessageScalarWhereInput!]
}

input MessageUpdateInput {
  author: PersonUpdateOneWithoutMessagesInput
  content: StringFieldUpdateOperationsInput
  conversation: ConversationUpdateOneRequiredWithoutMessagesInput
  createdAt: DateTimeFieldUpdateOperationsInput
}

input MessageUpdateManyMutationInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
}

input MessageUpdateManyWithoutAuthorInput {
  connect: [MessageWhereUniqueInput!]
  connectOrCreate: [MessageCreateOrConnectWithoutauthorInput!]
  create: [MessageCreateWithoutAuthorInput!]
  delete: [MessageWhereUniqueInput!]
  deleteMany: [MessageScalarWhereInput!]
  disconnect: [MessageWhereUniqueInput!]
  set: [MessageWhereUniqueInput!]
  update: [MessageUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [MessageUpdateManyWithWhereWithoutAuthorInput!]
  upsert: [MessageUpsertWithWhereUniqueWithoutAuthorInput!]
}

input MessageUpdateManyWithoutConversationInput {
  connect: [MessageWhereUniqueInput!]
  connectOrCreate: [MessageCreateOrConnectWithoutconversationInput!]
  create: [MessageCreateWithoutConversationInput!]
  delete: [MessageWhereUniqueInput!]
  deleteMany: [MessageScalarWhereInput!]
  disconnect: [MessageWhereUniqueInput!]
  set: [MessageWhereUniqueInput!]
  update: [MessageUpdateWithWhereUniqueWithoutConversationInput!]
  updateMany: [MessageUpdateManyWithWhereWithoutConversationInput!]
  upsert: [MessageUpsertWithWhereUniqueWithoutConversationInput!]
}

input MessageUpdateManyWithWhereWithoutAuthorInput {
  data: MessageUpdateManyMutationInput!
  where: MessageScalarWhereInput!
}

input MessageUpdateManyWithWhereWithoutConversationInput {
  data: MessageUpdateManyMutationInput!
  where: MessageScalarWhereInput!
}

input MessageUpdateWithoutAuthorInput {
  content: StringFieldUpdateOperationsInput
  conversation: ConversationUpdateOneRequiredWithoutMessagesInput
  createdAt: DateTimeFieldUpdateOperationsInput
}

input MessageUpdateWithoutConversationInput {
  author: PersonUpdateOneWithoutMessagesInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
}

input MessageUpdateWithWhereUniqueWithoutAuthorInput {
  data: MessageUpdateWithoutAuthorInput!
  where: MessageWhereUniqueInput!
}

input MessageUpdateWithWhereUniqueWithoutConversationInput {
  data: MessageUpdateWithoutConversationInput!
  where: MessageWhereUniqueInput!
}

input MessageUpsertWithWhereUniqueWithoutAuthorInput {
  create: MessageCreateWithoutAuthorInput!
  update: MessageUpdateWithoutAuthorInput!
  where: MessageWhereUniqueInput!
}

input MessageUpsertWithWhereUniqueWithoutConversationInput {
  create: MessageCreateWithoutConversationInput!
  update: MessageUpdateWithoutConversationInput!
  where: MessageWhereUniqueInput!
}

input MessageWhereUniqueInput {
  id: Int
}

type Mutation {
  addPersonToConversation(conversationId: Int!, personId: Int!): Conversation!
  createMessage(content: String!, conversationId: Int!): Message!
  createOneConversation(data: ConversationCreateInput!): Conversation!
  deleteOneConversation(where: ConversationWhereUniqueInput!): Conversation
  deleteOneMessage(where: MessageWhereUniqueInput!): Message
  deleteOnePerson(where: PersonWhereUniqueInput!): Person
  markConvAsRead(conversationId: Int!): LastRead!
  register(email: String!, password: String!, username: String!): Person!
  removePersonFromConversation(conversationId: Int!, personId: Int!): Conversation!
  updateOneConversation(data: ConversationUpdateInput!, where: ConversationWhereUniqueInput!): Conversation
  updateOneMessage(data: MessageUpdateInput!, where: MessageWhereUniqueInput!): Message
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

"""
PageInfo cursor, as defined in https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """
  The cursor corresponding to the last nodes in edges. Null if the connection is empty.
  """
  endCursor: String

  """
  Used to indicate whether more edges exist following the set defined by the clients arguments.
  """
  hasNextPage: Boolean!

  """
  Used to indicate whether more edges exist prior to the set defined by the clients arguments.
  """
  hasPreviousPage: Boolean!

  """
  The cursor corresponding to the first nodes in edges. Null if the connection is empty.
  """
  startCursor: String
}

type Person {
  conversations(
    """Returns the elements in the list that come after the specified cursor"""
    after: String

    """Returns the elements in the list that come before the specified cursor"""
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int
  ): ConversationConnection!
  createdAt: DateTime!
  email: String!
  id: Int!
  isActive: Boolean!
  isAdmin: Boolean!
  lastSeen: DateTime
  username: String!
}

input PersonCreateManyWithoutConversationsInput {
  connect: [PersonWhereUniqueInput!]
  connectOrCreate: [PersonCreateOrConnectWithoutconversationsInput!]
  create: [PersonCreateWithoutConversationsInput!]
}

input PersonCreateOneWithoutLastReadInput {
  connect: PersonWhereUniqueInput
  connectOrCreate: PersonCreateOrConnectWithoutlastReadInput
  create: PersonCreateWithoutLastReadInput
}

input PersonCreateOneWithoutMessagesInput {
  connect: PersonWhereUniqueInput
  connectOrCreate: PersonCreateOrConnectWithoutmessagesInput
  create: PersonCreateWithoutMessagesInput
}

input PersonCreateOrConnectWithoutconversationsInput {
  create: PersonCreateWithoutConversationsInput!
  where: PersonWhereUniqueInput!
}

input PersonCreateOrConnectWithoutlastReadInput {
  create: PersonCreateWithoutLastReadInput!
  where: PersonWhereUniqueInput!
}

input PersonCreateOrConnectWithoutmessagesInput {
  create: PersonCreateWithoutMessagesInput!
  where: PersonWhereUniqueInput!
}

input PersonCreateWithoutConversationsInput {
  createdAt: DateTime
  email: String!
  hash: String!
  isAdmin: Boolean
  lastRead: LastReadCreateManyWithoutPersonInput
  lastSeen: DateTime
  messages: MessageCreateManyWithoutAuthorInput
  username: String!
}

input PersonCreateWithoutLastReadInput {
  conversations: ConversationCreateManyWithoutParticipantsInput
  createdAt: DateTime
  email: String!
  hash: String!
  isAdmin: Boolean
  lastSeen: DateTime
  messages: MessageCreateManyWithoutAuthorInput
  username: String!
}

input PersonCreateWithoutMessagesInput {
  conversations: ConversationCreateManyWithoutParticipantsInput
  createdAt: DateTime
  email: String!
  hash: String!
  isAdmin: Boolean
  lastRead: LastReadCreateManyWithoutPersonInput
  lastSeen: DateTime
  username: String!
}

input PersonIDConversationIDCompoundUniqueInput {
  conversationID: Int!
  personID: Int!
}

input PersonScalarWhereInput {
  AND: [PersonScalarWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  hash: StringFilter
  id: IntFilter
  isAdmin: BoolFilter
  lastSeen: DateTimeNullableFilter
  NOT: [PersonScalarWhereInput!]
  OR: [PersonScalarWhereInput!]
  username: StringFilter
}

input PersonUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  hash: StringFieldUpdateOperationsInput
  isAdmin: BoolFieldUpdateOperationsInput
  lastSeen: NullableDateTimeFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input PersonUpdateManyWithoutConversationsInput {
  connect: [PersonWhereUniqueInput!]
  connectOrCreate: [PersonCreateOrConnectWithoutconversationsInput!]
  create: [PersonCreateWithoutConversationsInput!]
  delete: [PersonWhereUniqueInput!]
  deleteMany: [PersonScalarWhereInput!]
  disconnect: [PersonWhereUniqueInput!]
  set: [PersonWhereUniqueInput!]
  update: [PersonUpdateWithWhereUniqueWithoutConversationsInput!]
  updateMany: [PersonUpdateManyWithWhereWithoutConversationsInput!]
  upsert: [PersonUpsertWithWhereUniqueWithoutConversationsInput!]
}

input PersonUpdateManyWithWhereWithoutConversationsInput {
  data: PersonUpdateManyMutationInput!
  where: PersonScalarWhereInput!
}

input PersonUpdateOneRequiredWithoutLastReadInput {
  connect: PersonWhereUniqueInput
  connectOrCreate: PersonCreateOrConnectWithoutlastReadInput
  create: PersonCreateWithoutLastReadInput
  update: PersonUpdateWithoutLastReadInput
  upsert: PersonUpsertWithoutLastReadInput
}

input PersonUpdateOneWithoutMessagesInput {
  connect: PersonWhereUniqueInput
  connectOrCreate: PersonCreateOrConnectWithoutmessagesInput
  create: PersonCreateWithoutMessagesInput
  delete: Boolean
  disconnect: Boolean
  update: PersonUpdateWithoutMessagesInput
  upsert: PersonUpsertWithoutMessagesInput
}

input PersonUpdateWithoutConversationsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  hash: StringFieldUpdateOperationsInput
  isAdmin: BoolFieldUpdateOperationsInput
  lastRead: LastReadUpdateManyWithoutPersonInput
  lastSeen: NullableDateTimeFieldUpdateOperationsInput
  messages: MessageUpdateManyWithoutAuthorInput
  username: StringFieldUpdateOperationsInput
}

input PersonUpdateWithoutLastReadInput {
  conversations: ConversationUpdateManyWithoutParticipantsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  hash: StringFieldUpdateOperationsInput
  isAdmin: BoolFieldUpdateOperationsInput
  lastSeen: NullableDateTimeFieldUpdateOperationsInput
  messages: MessageUpdateManyWithoutAuthorInput
  username: StringFieldUpdateOperationsInput
}

input PersonUpdateWithoutMessagesInput {
  conversations: ConversationUpdateManyWithoutParticipantsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  hash: StringFieldUpdateOperationsInput
  isAdmin: BoolFieldUpdateOperationsInput
  lastRead: LastReadUpdateManyWithoutPersonInput
  lastSeen: NullableDateTimeFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input PersonUpdateWithWhereUniqueWithoutConversationsInput {
  data: PersonUpdateWithoutConversationsInput!
  where: PersonWhereUniqueInput!
}

input PersonUpsertWithoutLastReadInput {
  create: PersonCreateWithoutLastReadInput!
  update: PersonUpdateWithoutLastReadInput!
}

input PersonUpsertWithoutMessagesInput {
  create: PersonCreateWithoutMessagesInput!
  update: PersonUpdateWithoutMessagesInput!
}

input PersonUpsertWithWhereUniqueWithoutConversationsInput {
  create: PersonCreateWithoutConversationsInput!
  update: PersonUpdateWithoutConversationsInput!
  where: PersonWhereUniqueInput!
}

input PersonWhereUniqueInput {
  email: String
  id: Int
  username: String
}

type Query {
  conversation(whereId: Int!): Conversation!
  conversations(after: ConversationWhereUniqueInput, before: ConversationWhereUniqueInput, first: Int, last: Int): [Conversation!]!
  login(password: String!, username: String!): Person!
  logout: Person!
  me: Person!
  message(where: MessageWhereUniqueInput!): Message
  messages(after: MessageWhereUniqueInput, before: MessageWhereUniqueInput, first: Int, last: Int): [Message!]!
  people(after: PersonWhereUniqueInput, before: PersonWhereUniqueInput, first: Int, last: Int): [Person!]!
  person(where: PersonWhereUniqueInput!): Person!
  sessionOwner: Person!
}

enum QueryMode {
  default
  insensitive
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

type Subscription {
  newMessages(conversationId: Int!): Message!
  personActiveStatus(userId: Int!): Boolean!
}
