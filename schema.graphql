### This file was generated by Nexus Schema
### Do not make changes to this file directly


input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type Conversation {
  createdAt: DateTime!
  id: Int!
  messages(after: MessageWhereUniqueInput, before: MessageWhereUniqueInput, first: Int, last: Int): [Message!]!
  name: String!
  participants(after: PersonWhereUniqueInput, before: PersonWhereUniqueInput, first: Int, last: Int): [Person!]!
}

type ConversationConnection {
  """
  https://facebook.github.io/relay/graphql/connections.htm#sec-Edge-Types
  """
  edges: [ConversationEdge!]!

  """
  https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo
  """
  pageInfo: PageInfo!
}

input ConversationCreateInput {
  createdAt: DateTime
  messages: MessageCreateManyWithoutConversationInput
  name: String!
  participants: PersonCreateManyWithoutConversationsInput
}

input ConversationCreateManyWithoutParticipantsInput {
  connect: [ConversationWhereUniqueInput!]
  connectOrCreate: [ConversationCreateOrConnectWithoutparticipantsInput!]
  create: [ConversationCreateWithoutParticipantsInput!]
}

input ConversationCreateOneWithoutMessagesInput {
  connect: ConversationWhereUniqueInput
  connectOrCreate: ConversationCreateOrConnectWithoutmessagesInput
  create: ConversationCreateWithoutMessagesInput
}

input ConversationCreateOrConnectWithoutmessagesInput {
  create: ConversationCreateWithoutMessagesInput!
  where: ConversationWhereUniqueInput!
}

input ConversationCreateOrConnectWithoutparticipantsInput {
  create: ConversationCreateWithoutParticipantsInput!
  where: ConversationWhereUniqueInput!
}

input ConversationCreateWithoutMessagesInput {
  createdAt: DateTime
  name: String!
  participants: PersonCreateManyWithoutConversationsInput
}

input ConversationCreateWithoutParticipantsInput {
  createdAt: DateTime
  messages: MessageCreateManyWithoutConversationInput
  name: String!
}

type ConversationEdge {
  """https://facebook.github.io/relay/graphql/connections.htm#sec-Cursor"""
  cursor: String!

  """https://facebook.github.io/relay/graphql/connections.htm#sec-Node"""
  node: Conversation!
}

input ConversationScalarWhereInput {
  AND: [ConversationScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  NOT: [ConversationScalarWhereInput!]
  OR: [ConversationScalarWhereInput!]
}

input ConversationUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  messages: MessageUpdateManyWithoutConversationInput
  name: StringFieldUpdateOperationsInput
  participants: PersonUpdateManyWithoutConversationsInput
}

input ConversationUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input ConversationUpdateManyWithoutParticipantsInput {
  connect: [ConversationWhereUniqueInput!]
  connectOrCreate: [ConversationCreateOrConnectWithoutparticipantsInput!]
  create: [ConversationCreateWithoutParticipantsInput!]
  delete: [ConversationWhereUniqueInput!]
  deleteMany: [ConversationScalarWhereInput!]
  disconnect: [ConversationWhereUniqueInput!]
  set: [ConversationWhereUniqueInput!]
  update: [ConversationUpdateWithWhereUniqueWithoutParticipantsInput!]
  updateMany: [ConversationUpdateManyWithWhereWithoutParticipantsInput!]
  upsert: [ConversationUpsertWithWhereUniqueWithoutParticipantsInput!]
}

input ConversationUpdateManyWithWhereWithoutParticipantsInput {
  data: ConversationUpdateManyMutationInput!
  where: ConversationScalarWhereInput!
}

input ConversationUpdateOneRequiredWithoutMessagesInput {
  connect: ConversationWhereUniqueInput
  connectOrCreate: ConversationCreateOrConnectWithoutmessagesInput
  create: ConversationCreateWithoutMessagesInput
  update: ConversationUpdateWithoutMessagesInput
  upsert: ConversationUpsertWithoutMessagesInput
}

input ConversationUpdateWithoutMessagesInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  participants: PersonUpdateManyWithoutConversationsInput
}

input ConversationUpdateWithoutParticipantsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  messages: MessageUpdateManyWithoutConversationInput
  name: StringFieldUpdateOperationsInput
}

input ConversationUpdateWithWhereUniqueWithoutParticipantsInput {
  data: ConversationUpdateWithoutParticipantsInput!
  where: ConversationWhereUniqueInput!
}

input ConversationUpsertWithoutMessagesInput {
  create: ConversationCreateWithoutMessagesInput!
  update: ConversationUpdateWithoutMessagesInput!
}

input ConversationUpsertWithWhereUniqueWithoutParticipantsInput {
  create: ConversationCreateWithoutParticipantsInput!
  update: ConversationUpdateWithoutParticipantsInput!
  where: ConversationWhereUniqueInput!
}

input ConversationWhereUniqueInput {
  id: Int
}

scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

type Message {
  author: Person
  authorID: Int
  content: String!
  conversation: Conversation!
  conversationID: Int!
  createdAt: DateTime!
  id: Int!
}

input MessageCreateManyWithoutAuthorInput {
  connect: [MessageWhereUniqueInput!]
  connectOrCreate: [MessageCreateOrConnectWithoutauthorInput!]
  create: [MessageCreateWithoutAuthorInput!]
}

input MessageCreateManyWithoutConversationInput {
  connect: [MessageWhereUniqueInput!]
  connectOrCreate: [MessageCreateOrConnectWithoutconversationInput!]
  create: [MessageCreateWithoutConversationInput!]
}

input MessageCreateOrConnectWithoutauthorInput {
  create: MessageCreateWithoutAuthorInput!
  where: MessageWhereUniqueInput!
}

input MessageCreateOrConnectWithoutconversationInput {
  create: MessageCreateWithoutConversationInput!
  where: MessageWhereUniqueInput!
}

input MessageCreateWithoutAuthorInput {
  content: String!
  conversation: ConversationCreateOneWithoutMessagesInput!
  createdAt: DateTime
}

input MessageCreateWithoutConversationInput {
  author: PersonCreateOneWithoutMessagesInput
  content: String!
  createdAt: DateTime
}

input MessageScalarWhereInput {
  AND: [MessageScalarWhereInput!]
  authorID: IntNullableFilter
  content: StringFilter
  conversationID: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  NOT: [MessageScalarWhereInput!]
  OR: [MessageScalarWhereInput!]
}

input MessageUpdateInput {
  author: PersonUpdateOneWithoutMessagesInput
  content: StringFieldUpdateOperationsInput
  conversation: ConversationUpdateOneRequiredWithoutMessagesInput
  createdAt: DateTimeFieldUpdateOperationsInput
}

input MessageUpdateManyMutationInput {
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
}

input MessageUpdateManyWithoutAuthorInput {
  connect: [MessageWhereUniqueInput!]
  connectOrCreate: [MessageCreateOrConnectWithoutauthorInput!]
  create: [MessageCreateWithoutAuthorInput!]
  delete: [MessageWhereUniqueInput!]
  deleteMany: [MessageScalarWhereInput!]
  disconnect: [MessageWhereUniqueInput!]
  set: [MessageWhereUniqueInput!]
  update: [MessageUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [MessageUpdateManyWithWhereWithoutAuthorInput!]
  upsert: [MessageUpsertWithWhereUniqueWithoutAuthorInput!]
}

input MessageUpdateManyWithoutConversationInput {
  connect: [MessageWhereUniqueInput!]
  connectOrCreate: [MessageCreateOrConnectWithoutconversationInput!]
  create: [MessageCreateWithoutConversationInput!]
  delete: [MessageWhereUniqueInput!]
  deleteMany: [MessageScalarWhereInput!]
  disconnect: [MessageWhereUniqueInput!]
  set: [MessageWhereUniqueInput!]
  update: [MessageUpdateWithWhereUniqueWithoutConversationInput!]
  updateMany: [MessageUpdateManyWithWhereWithoutConversationInput!]
  upsert: [MessageUpsertWithWhereUniqueWithoutConversationInput!]
}

input MessageUpdateManyWithWhereWithoutAuthorInput {
  data: MessageUpdateManyMutationInput!
  where: MessageScalarWhereInput!
}

input MessageUpdateManyWithWhereWithoutConversationInput {
  data: MessageUpdateManyMutationInput!
  where: MessageScalarWhereInput!
}

input MessageUpdateWithoutAuthorInput {
  content: StringFieldUpdateOperationsInput
  conversation: ConversationUpdateOneRequiredWithoutMessagesInput
  createdAt: DateTimeFieldUpdateOperationsInput
}

input MessageUpdateWithoutConversationInput {
  author: PersonUpdateOneWithoutMessagesInput
  content: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
}

input MessageUpdateWithWhereUniqueWithoutAuthorInput {
  data: MessageUpdateWithoutAuthorInput!
  where: MessageWhereUniqueInput!
}

input MessageUpdateWithWhereUniqueWithoutConversationInput {
  data: MessageUpdateWithoutConversationInput!
  where: MessageWhereUniqueInput!
}

input MessageUpsertWithWhereUniqueWithoutAuthorInput {
  create: MessageCreateWithoutAuthorInput!
  update: MessageUpdateWithoutAuthorInput!
  where: MessageWhereUniqueInput!
}

input MessageUpsertWithWhereUniqueWithoutConversationInput {
  create: MessageCreateWithoutConversationInput!
  update: MessageUpdateWithoutConversationInput!
  where: MessageWhereUniqueInput!
}

input MessageWhereUniqueInput {
  id: Int
}

type Mutation {
  addPersonToConversation(conversationId: Int!, personId: Int!): Conversation!
  createMessage(content: String!, conversationId: Int!): Message!
  createOneConversation(data: ConversationCreateInput!): Conversation!
  deleteOneConversation(where: ConversationWhereUniqueInput!): Conversation
  deleteOneMessage(where: MessageWhereUniqueInput!): Message
  deleteOnePerson(where: PersonWhereUniqueInput!): Person
  register(email: String!, password: String!, username: String!): Person!
  removePersonFromConversation(conversationId: Int!, personId: Int!): Conversation!
  updateOneConversation(data: ConversationUpdateInput!, where: ConversationWhereUniqueInput!): Conversation
  updateOneMessage(data: MessageUpdateInput!, where: MessageWhereUniqueInput!): Message
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

"""
PageInfo cursor, as defined in https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """
  The cursor corresponding to the last nodes in edges. Null if the connection is empty.
  """
  endCursor: String

  """
  Used to indicate whether more edges exist following the set defined by the clients arguments.
  """
  hasNextPage: Boolean!

  """
  Used to indicate whether more edges exist prior to the set defined by the clients arguments.
  """
  hasPreviousPage: Boolean!

  """
  The cursor corresponding to the first nodes in edges. Null if the connection is empty.
  """
  startCursor: String
}

type Person {
  conversations(
    """Returns the elements in the list that come after the specified cursor"""
    after: String

    """Returns the elements in the list that come before the specified cursor"""
    before: String

    """Returns the first n elements from the list."""
    first: Int

    """Returns the last n elements from the list."""
    last: Int
  ): ConversationConnection!
  createdAt: DateTime!
  email: String!
  id: Int!
  isActive: Boolean!
  isAdmin: Boolean!
  lastSeen: DateTime
  username: String!
}

input PersonCreateManyWithoutConversationsInput {
  connect: [PersonWhereUniqueInput!]
  connectOrCreate: [PersonCreateOrConnectWithoutconversationsInput!]
  create: [PersonCreateWithoutConversationsInput!]
}

input PersonCreateOneWithoutMessagesInput {
  connect: PersonWhereUniqueInput
  connectOrCreate: PersonCreateOrConnectWithoutmessagesInput
  create: PersonCreateWithoutMessagesInput
}

input PersonCreateOrConnectWithoutconversationsInput {
  create: PersonCreateWithoutConversationsInput!
  where: PersonWhereUniqueInput!
}

input PersonCreateOrConnectWithoutmessagesInput {
  create: PersonCreateWithoutMessagesInput!
  where: PersonWhereUniqueInput!
}

input PersonCreateWithoutConversationsInput {
  createdAt: DateTime
  email: String!
  hash: String!
  isActive: Boolean
  isAdmin: Boolean
  lastSeen: DateTime
  messages: MessageCreateManyWithoutAuthorInput
  username: String!
}

input PersonCreateWithoutMessagesInput {
  conversations: ConversationCreateManyWithoutParticipantsInput
  createdAt: DateTime
  email: String!
  hash: String!
  isActive: Boolean
  isAdmin: Boolean
  lastSeen: DateTime
  username: String!
}

input PersonScalarWhereInput {
  AND: [PersonScalarWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  hash: StringFilter
  id: IntFilter
  isActive: BoolFilter
  isAdmin: BoolFilter
  lastSeen: DateTimeNullableFilter
  NOT: [PersonScalarWhereInput!]
  OR: [PersonScalarWhereInput!]
  username: StringFilter
}

input PersonUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  hash: StringFieldUpdateOperationsInput
  isActive: BoolFieldUpdateOperationsInput
  isAdmin: BoolFieldUpdateOperationsInput
  lastSeen: NullableDateTimeFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input PersonUpdateManyWithoutConversationsInput {
  connect: [PersonWhereUniqueInput!]
  connectOrCreate: [PersonCreateOrConnectWithoutconversationsInput!]
  create: [PersonCreateWithoutConversationsInput!]
  delete: [PersonWhereUniqueInput!]
  deleteMany: [PersonScalarWhereInput!]
  disconnect: [PersonWhereUniqueInput!]
  set: [PersonWhereUniqueInput!]
  update: [PersonUpdateWithWhereUniqueWithoutConversationsInput!]
  updateMany: [PersonUpdateManyWithWhereWithoutConversationsInput!]
  upsert: [PersonUpsertWithWhereUniqueWithoutConversationsInput!]
}

input PersonUpdateManyWithWhereWithoutConversationsInput {
  data: PersonUpdateManyMutationInput!
  where: PersonScalarWhereInput!
}

input PersonUpdateOneWithoutMessagesInput {
  connect: PersonWhereUniqueInput
  connectOrCreate: PersonCreateOrConnectWithoutmessagesInput
  create: PersonCreateWithoutMessagesInput
  delete: Boolean
  disconnect: Boolean
  update: PersonUpdateWithoutMessagesInput
  upsert: PersonUpsertWithoutMessagesInput
}

input PersonUpdateWithoutConversationsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  hash: StringFieldUpdateOperationsInput
  isActive: BoolFieldUpdateOperationsInput
  isAdmin: BoolFieldUpdateOperationsInput
  lastSeen: NullableDateTimeFieldUpdateOperationsInput
  messages: MessageUpdateManyWithoutAuthorInput
  username: StringFieldUpdateOperationsInput
}

input PersonUpdateWithoutMessagesInput {
  conversations: ConversationUpdateManyWithoutParticipantsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  hash: StringFieldUpdateOperationsInput
  isActive: BoolFieldUpdateOperationsInput
  isAdmin: BoolFieldUpdateOperationsInput
  lastSeen: NullableDateTimeFieldUpdateOperationsInput
  username: StringFieldUpdateOperationsInput
}

input PersonUpdateWithWhereUniqueWithoutConversationsInput {
  data: PersonUpdateWithoutConversationsInput!
  where: PersonWhereUniqueInput!
}

input PersonUpsertWithoutMessagesInput {
  create: PersonCreateWithoutMessagesInput!
  update: PersonUpdateWithoutMessagesInput!
}

input PersonUpsertWithWhereUniqueWithoutConversationsInput {
  create: PersonCreateWithoutConversationsInput!
  update: PersonUpdateWithoutConversationsInput!
  where: PersonWhereUniqueInput!
}

input PersonWhereUniqueInput {
  email: String
  id: Int
  username: String
}

type Query {
  conversation(whereId: Int!): Conversation!
  conversations(after: ConversationWhereUniqueInput, before: ConversationWhereUniqueInput, first: Int, last: Int): [Conversation!]!
  login(password: String!, username: String!): Person!
  logout: Person!
  me: Person!
  message(where: MessageWhereUniqueInput!): Message
  messages(after: MessageWhereUniqueInput, before: MessageWhereUniqueInput, first: Int, last: Int): [Message!]!
  people(after: PersonWhereUniqueInput, before: PersonWhereUniqueInput, first: Int, last: Int): [Person!]!
  person(where: PersonWhereUniqueInput!): Person!
  sessionOwner: Person!
}

enum QueryMode {
  default
  insensitive
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

type Subscription {
  newMessages(conversationId: Int!): Message!
}
